# Experiment #

import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import random
import time
import math
import optuna
from forceatlas import ForceAtlas2

Graph = nx.read_gexf("/content/tree_03_06.gexf")   #can change the dataset
print(Graph)

def v2dis(G, pos):
  distances = {}
  sum = 0
  count = 0
  for v1 in pos:
    for v2 in pos:
      if v1 != v2:
        x1, y1 = pos[v1]
        x2, y2 = pos[v2]
        distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        distances[(v1,v2)] = distance
        sum += distance
        count += 1
  return distances, sum/count

def qedge(G, dis_dict):
  edge_list = list(G.edges())
  e = len(edge_list)
  sum = 0
  for i in edge_list:
    a, b = i
    index = (int(a), int(b))
    if index in dis_dict:
      distance = dis_dict[index]
      sum += distance
  return sum/e

def quality(G, pos):
  dis_dict, down = v2dis(G, pos)
  up = qedge(G, dis_dict)
  return down/up

def show_network(
    Graph,
    iters,
    adjust_sizes=True,
    directed=False, # directed=True
    gravity=0.5,
    jitter_tolerance=1.0,
    barnes_hut_threta=1.2,
    barnes_hut_optimize=True,
    scaling_ratio=2.0,
    outbound_attraction_distribution=True,
    strong_gravity_mode =False,
    linlog=False):
    G = nx.to_numpy_array(Graph)
    forceatlas2 = ForceAtlas2(G, iterations=iters, lin_log_mode=linlog)
    pos = forceatlas2.run_algo()
    pos = [(x, y) for x, y in pos]
    pos = {i: pos[i] for i in range(len(pos))}
    G = nx.from_numpy_array(G)
    nx.draw(G, pos=pos, with_labels=False, node_size=30)
    return pos

def objective(trial):
    iters = trial.suggest_int("iteration", 100, 200, step=50)
    gravity = trial.suggest_float("gravity", 0.5, 5,step=0.5)
    adjust_sizes = trial.suggest_categorical("adjust_sizes", [True, False])
    jitter_tolerance=trial.suggest_float("jitter_tolerance", 1.0, 3.0)
    barnes_hut_threta=trial.suggest_float("barnes_hut_threta", 1.2, 3.2)
    barnes_hut_optimize=trial.suggest_categorical("barnes_hut_optimize", [True, False])
    scaling_ratio=trial.suggest_float("scaling_ratio", 2.0, 3.0)
    pos = show_network(Graph, iters, gravity, adjust_sizes, jitter_tolerance, barnes_hut_optimize, scaling_ratio, linlog=False)
    x = quality(Graph, pos)
    return x

def search():
    study = optuna.create_study(direction="maximize")
    study.optimize(objective, n_trials=3)
    return study.best_params

search()   # will print out the best combination and the visual layout




'''   #Pre-Experiment#


# print out the quality history curve

start_time = time.time()
pos3 = show_network(Graph,3)
end_time = time.time()
time3 = end_time - start_time

start_time = time.time()
pos10 = show_network(Graph,10)
end_time = time.time()
time10 = end_time - start_time

start_time = time.time()
pos30 = show_network(Graph,30)
end_time = time.time()
time30 = end_time - start_time

start_time = time.time()
pos60 = show_network(Graph,60)
end_time = time.time()
time60 = end_time - start_time

start_time = time.time()
pos100 = show_network(Graph,100)
end_time = time.time()
time100 = end_time - start_time

start_time = time.time()
pos150 = show_network(Graph,150)
end_time = time.time()
time150 = end_time - start_time

start_time = time.time()
pos200 = show_network(Graph,200)
end_time = time.time()
time200 = end_time - start_time

start_time = time.time()
pos250 = show_network(Graph,250)
end_time = time.time()
time250 = end_time - start_time

p3 = quality(Graph, pos3)
p10 = quality(Graph, pos10)
p30 = quality(Graph, pos30)
p60 = quality(Graph, pos60)
p100 = quality(Graph, pos100)
p150 = quality(Graph, pos150)
p200 = quality(Graph, pos200)
p250 = quality(Graph, pos250)

print(p3, p10, p30, p60, p100, p150, p200, p250)

dot = [p3, p10, p30, p60, p100, p150, p200, p250]
time = [time3, time10, time30, time60, time100, time150, time200, time250]

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(time, dot, color='skyblue')
ax.scatter(time, dot, color='purple', marker='o')
ax.set_xlabel('time/seconds', fontsize=10)
ax.set_ylabel('Quality', fontsize=10)
ax.legend(fontsize=10)
plt.show()


# Performance: The more time, the less quality improve
def performance(Graph, pos, time): 
  q = quality(Graph, pos)
  return q/time

a = performance(Graph, pos3, time3)
b = performance(Graph, pos10, time10)
c = performance(Graph, pos30, time30)
d = performance(Graph, pos60, time60)
e = performance(Graph, pos100, time100)
f = performance(Graph, pos150, time150)
g = performance(Graph, pos200, time200)
h = performance(Graph, pos250, time250)
print(a,b,c,d,e,f,g)



# find the acceptable quality with performance <threshold, then stop iteration
def find_iter(G, epoch):  #epoch is maximum value
  timelist = []
  qualitylist = []
  for i in range(1,epoch):
    start_time = time.time()
    pos = show_network(Graph, i*10, linlog=False)
    end_time = time.time()
    t = end_time - start_time
    timelist.append(t)
    qual = quality(G, pos)
    qualitylist.append(qual)
    if qual/t < 0.05:  # can change the threshold here 
      break
  return timelist, qualitylist, i

timelist, qualitylist, i = find_iter(Graph, 50)
print(timelist, qualitylist, i)   # i is the target iteration time

'''
